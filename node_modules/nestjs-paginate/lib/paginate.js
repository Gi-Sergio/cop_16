"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.paginate = exports.NO_PAGINATION = exports.DEFAULT_LIMIT = exports.DEFAULT_MAX_LIMIT = exports.PaginationType = exports.Paginated = exports.FilterSuffix = exports.FilterOperator = void 0;
const typeorm_1 = require("typeorm");
const common_1 = require("@nestjs/common");
const lodash_1 = require("lodash");
const querystring_1 = require("querystring");
const helper_1 = require("./helper");
const filter_1 = require("./filter");
Object.defineProperty(exports, "FilterOperator", { enumerable: true, get: function () { return filter_1.FilterOperator; } });
Object.defineProperty(exports, "FilterSuffix", { enumerable: true, get: function () { return filter_1.FilterSuffix; } });
const OrmUtils_1 = require("typeorm/util/OrmUtils");
const logger = new common_1.Logger('nestjs-paginate');
class Paginated {
}
exports.Paginated = Paginated;
var PaginationType;
(function (PaginationType) {
    PaginationType["LIMIT_AND_OFFSET"] = "limit";
    PaginationType["TAKE_AND_SKIP"] = "take";
})(PaginationType || (exports.PaginationType = PaginationType = {}));
exports.DEFAULT_MAX_LIMIT = 100;
exports.DEFAULT_LIMIT = 20;
exports.NO_PAGINATION = 0;
function generateWhereStatement(queryBuilder, obj) {
    const toTransform = Array.isArray(obj) ? obj : [obj];
    return toTransform.map((item) => flattenWhereAndTransform(queryBuilder, item).join(' AND ')).join(' OR ');
}
function flattenWhereAndTransform(queryBuilder, obj, separator = '.', parentKey = '') {
    return Object.entries(obj).flatMap(([key, value]) => {
        if (obj.hasOwnProperty(key)) {
            const joinedKey = parentKey ? `${parentKey}${separator}${key}` : key;
            if (typeof value === 'object' && value !== null && !(value instanceof typeorm_1.FindOperator)) {
                return flattenWhereAndTransform(queryBuilder, value, separator, joinedKey);
            }
            else {
                const property = (0, helper_1.getPropertiesByColumnName)(joinedKey);
                const { isVirtualProperty, query: virtualQuery } = (0, helper_1.extractVirtualProperty)(queryBuilder, property);
                const isRelation = (0, helper_1.checkIsRelation)(queryBuilder, property.propertyPath);
                const isEmbedded = (0, helper_1.checkIsEmbedded)(queryBuilder, property.propertyPath);
                const alias = (0, helper_1.fixColumnAlias)(property, queryBuilder.alias, isRelation, isVirtualProperty, isEmbedded, virtualQuery);
                const whereClause = queryBuilder['createWhereConditionExpression'](queryBuilder['getWherePredicateCondition'](alias, value));
                const allJoinedTables = queryBuilder.expressionMap.joinAttributes.reduce((acc, attr) => {
                    acc[attr.alias.name] = true;
                    return acc;
                }, {});
                const allTablesInPath = property.column.split('.').slice(0, -1);
                const tablesToJoin = allTablesInPath.map((table, idx) => {
                    if (idx === 0) {
                        return table;
                    }
                    return [...allTablesInPath.slice(0, idx), table].join('.');
                });
                tablesToJoin.forEach((table) => {
                    const pathSplit = table.split('.');
                    const fullPath = pathSplit.length === 1
                        ? ''
                        : `_${pathSplit
                            .slice(0, -1)
                            .map((p) => p + '_rel')
                            .join('_')}`;
                    const tableName = pathSplit[pathSplit.length - 1];
                    const tableAliasWithProperty = `${queryBuilder.alias}${fullPath}.${tableName}`;
                    const joinTableAlias = `${queryBuilder.alias}${fullPath}_${tableName}_rel`;
                    const baseTableAlias = allJoinedTables[joinTableAlias];
                    if (baseTableAlias) {
                        return;
                    }
                    else {
                        queryBuilder.leftJoin(tableAliasWithProperty, joinTableAlias);
                    }
                });
                return whereClause;
            }
        }
    });
}
async function paginate(query, repo, config) {
    var _a;
    const page = (0, helper_1.positiveNumberOrDefault)(query.page, 1, 1);
    const defaultLimit = config.defaultLimit || exports.DEFAULT_LIMIT;
    const maxLimit = (0, helper_1.positiveNumberOrDefault)(config.maxLimit, exports.DEFAULT_MAX_LIMIT);
    const queryLimit = (0, helper_1.positiveNumberOrDefault)(query.limit, defaultLimit);
    const isPaginated = !(queryLimit === exports.NO_PAGINATION && maxLimit === exports.NO_PAGINATION);
    const limit = isPaginated ? Math.min(queryLimit || defaultLimit, maxLimit || exports.DEFAULT_MAX_LIMIT) : exports.NO_PAGINATION;
    const sortBy = [];
    const searchBy = [];
    let [items, totalItems] = [[], 0];
    const queryBuilder = repo instanceof typeorm_1.Repository ? repo.createQueryBuilder('__root') : repo;
    if (repo instanceof typeorm_1.Repository && !config.relations && config.loadEagerRelations === true) {
        if (!config.relations) {
            typeorm_1.FindOptionsUtils.joinEagerRelations(queryBuilder, queryBuilder.alias, repo.metadata);
        }
    }
    if (isPaginated) {
        // Allow user to choose between limit/offset and take/skip.
        // However, using limit/offset can cause problems when joining one-to-many etc.
        if (config.paginationType === PaginationType.LIMIT_AND_OFFSET) {
            queryBuilder.limit(limit).offset((page - 1) * limit);
        }
        else {
            queryBuilder.take(limit).skip((page - 1) * limit);
        }
    }
    if (config.relations) {
        const relations = Array.isArray(config.relations)
            ? OrmUtils_1.OrmUtils.propertyPathsToTruthyObject(config.relations)
            : config.relations;
        const createQueryBuilderRelations = (prefix, relations, alias) => {
            Object.keys(relations).forEach((relationName) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const relationSchema = relations[relationName];
                queryBuilder.leftJoinAndSelect(`${alias !== null && alias !== void 0 ? alias : prefix}.${relationName}`, `${alias !== null && alias !== void 0 ? alias : prefix}_${relationName}_rel`);
                if (typeof relationSchema === 'object') {
                    createQueryBuilderRelations(relationName, relationSchema, `${alias !== null && alias !== void 0 ? alias : prefix}_${relationName}_rel`);
                }
            });
        };
        createQueryBuilderRelations(queryBuilder.alias, relations);
    }
    let nullSort = undefined;
    if (config.nullSort) {
        nullSort = config.nullSort === 'last' ? 'NULLS LAST' : 'NULLS FIRST';
    }
    if (config.sortableColumns.length < 1) {
        const message = "Missing required 'sortableColumns' config.";
        logger.debug(message);
        throw new common_1.ServiceUnavailableException(message);
    }
    if (query.sortBy) {
        for (const order of query.sortBy) {
            if ((0, helper_1.isEntityKey)(config.sortableColumns, order[0]) && ['ASC', 'DESC'].includes(order[1])) {
                sortBy.push(order);
            }
        }
    }
    if (!sortBy.length) {
        sortBy.push(...(config.defaultSortBy || [[config.sortableColumns[0], 'ASC']]));
    }
    for (const order of sortBy) {
        const columnProperties = (0, helper_1.getPropertiesByColumnName)(order[0]);
        const { isVirtualProperty } = (0, helper_1.extractVirtualProperty)(queryBuilder, columnProperties);
        const isRelation = (0, helper_1.checkIsRelation)(queryBuilder, columnProperties.propertyPath);
        const isEmbeded = (0, helper_1.checkIsEmbedded)(queryBuilder, columnProperties.propertyPath);
        let alias = (0, helper_1.fixColumnAlias)(columnProperties, queryBuilder.alias, isRelation, isVirtualProperty, isEmbeded);
        if (isVirtualProperty) {
            alias = `"${alias}"`;
        }
        queryBuilder.addOrderBy(alias, order[1], nullSort);
    }
    // When we partial select the columns (main or relation) we must add the primary key column otherwise
    // typeorm will not be able to map the result.
    let selectParams = config.select && query.select && !config.ignoreSelectInQueryParam
        ? config.select.filter((column) => query.select.includes(column))
        : config.select;
    if (!(0, helper_1.includesAllPrimaryKeyColumns)(queryBuilder, query.select)) {
        selectParams = config.select;
    }
    if ((selectParams === null || selectParams === void 0 ? void 0 : selectParams.length) > 0 && (0, helper_1.includesAllPrimaryKeyColumns)(queryBuilder, selectParams)) {
        const cols = selectParams.reduce((cols, currentCol) => {
            const columnProperties = (0, helper_1.getPropertiesByColumnName)(currentCol);
            const isRelation = (0, helper_1.checkIsRelation)(queryBuilder, columnProperties.propertyPath);
            cols.push((0, helper_1.fixColumnAlias)(columnProperties, queryBuilder.alias, isRelation));
            return cols;
        }, []);
        queryBuilder.select(cols);
    }
    if (config.where && repo instanceof typeorm_1.Repository) {
        const baseWhereStr = generateWhereStatement(queryBuilder, config.where);
        queryBuilder.andWhere(`(${baseWhereStr})`);
    }
    if (config.withDeleted) {
        queryBuilder.withDeleted();
    }
    if (config.searchableColumns) {
        if (query.searchBy && !config.ignoreSearchByInQueryParam) {
            for (const column of query.searchBy) {
                if ((0, helper_1.isEntityKey)(config.searchableColumns, column)) {
                    searchBy.push(column);
                }
            }
        }
        else {
            searchBy.push(...config.searchableColumns);
        }
    }
    if (query.search && searchBy.length) {
        queryBuilder.andWhere(new typeorm_1.Brackets((qb) => {
            for (const column of searchBy) {
                const property = (0, helper_1.getPropertiesByColumnName)(column);
                const { isVirtualProperty, query: virtualQuery } = (0, helper_1.extractVirtualProperty)(qb, property);
                const isRelation = (0, helper_1.checkIsRelation)(qb, property.propertyPath);
                const isEmbeded = (0, helper_1.checkIsEmbedded)(qb, property.propertyPath);
                const alias = (0, helper_1.fixColumnAlias)(property, qb.alias, isRelation, isVirtualProperty, isEmbeded, virtualQuery);
                const condition = {
                    operator: 'ilike',
                    parameters: [alias, `:${property.column}`],
                };
                if (['postgres', 'cockroachdb'].includes(queryBuilder.connection.options.type)) {
                    condition.parameters[0] = `CAST(${condition.parameters[0]} AS text)`;
                }
                qb.orWhere(qb['createWhereConditionExpression'](condition), {
                    [property.column]: `%${query.search}%`,
                });
            }
        }));
    }
    if (query.filter) {
        (0, filter_1.addFilter)(queryBuilder, query, config.filterableColumns);
    }
    if (isPaginated) {
        ;
        [items, totalItems] = await queryBuilder.getManyAndCount();
    }
    else {
        items = await queryBuilder.getMany();
    }
    let path;
    const { queryOrigin, queryPath } = (0, helper_1.getQueryUrlComponents)(query.path);
    if (config.relativePath) {
        path = queryPath;
    }
    else if (config.origin) {
        path = config.origin + queryPath;
    }
    else {
        path = queryOrigin + queryPath;
    }
    const sortByQuery = sortBy.map((order) => `&sortBy=${order.join(':')}`).join('');
    const searchQuery = query.search ? `&search=${query.search}` : '';
    const searchByQuery = query.searchBy && searchBy.length && !config.ignoreSearchByInQueryParam
        ? searchBy.map((column) => `&searchBy=${column}`).join('')
        : '';
    // Only expose select in meta data if query select differs from config select
    const isQuerySelected = (selectParams === null || selectParams === void 0 ? void 0 : selectParams.length) !== ((_a = config.select) === null || _a === void 0 ? void 0 : _a.length);
    const selectQuery = isQuerySelected ? `&select=${selectParams.join(',')}` : '';
    const filterQuery = query.filter
        ? '&' +
            (0, querystring_1.stringify)((0, lodash_1.mapKeys)(query.filter, (_param, name) => 'filter.' + name), '&', '=', { encodeURIComponent: (str) => str })
        : '';
    const options = `&limit=${limit}${sortByQuery}${searchQuery}${searchByQuery}${selectQuery}${filterQuery}`;
    const buildLink = (p) => path + '?page=' + p + options;
    const totalPages = isPaginated ? Math.ceil(totalItems / limit) : 1;
    const results = {
        data: items,
        meta: {
            itemsPerPage: isPaginated ? limit : items.length,
            totalItems: isPaginated ? totalItems : items.length,
            currentPage: page,
            totalPages,
            sortBy,
            search: query.search,
            searchBy: query.search ? searchBy : undefined,
            select: isQuerySelected ? selectParams : undefined,
            filter: query.filter,
        },
        links: {
            first: page == 1 ? undefined : buildLink(1),
            previous: page - 1 < 1 ? undefined : buildLink(page - 1),
            current: buildLink(page),
            next: page + 1 > totalPages ? undefined : buildLink(page + 1),
            last: page == totalPages || !totalItems ? undefined : buildLink(totalPages),
        },
    };
    return Object.assign(new Paginated(), results);
}
exports.paginate = paginate;
//# sourceMappingURL=paginate.js.map